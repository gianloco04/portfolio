<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dots Grid - Enhanced</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<style>
  * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  min-height: 100vh;
  background-color: #e5e5e5;
  padding: 2rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.container {
  max-width: 80rem;
  margin: 0 auto;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  justify-content: center;
  margin-bottom: 2rem;
}

.btn {
  padding: 0.5rem;
  height: 50px;
  min-width: 50px;
  border: none;
  border-radius: 2rem;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  transition: all 0.2s;
  border: 1px solid #aaa;
  background: #e5e5e5;
  color: #2c2c2c;
}

.btn-secondary {
  background-color: #2c2c2c;
  color: white;
}

.btn-success {
  background-color: #22c55e;
  color: white;
}

.btn-wide {
  width: auto;
  padding: 0.5rem 1rem;
}

.grids-container {
  display: flex;
  gap: 4rem;
  justify-content: center;
  align-items: flex-start;
  flex-wrap: wrap;
}

.grid-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.grid-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #2c2c2c;
}

.grid-wrapper {
  display: flex;
  justify-content: center;
}

.grid {
  display: inline-grid;
  grid-template-columns: repeat(16, 30px);
  grid-template-rows: repeat(16, 30px);
  gap: 0;
  background-color: white;
  border: 2px solid #aaa;
}

.grid.readonly {
  border-color: #22c55e;
}

.cell {
  position: relative;
  width: 30px;
  height: 30px;
  cursor: pointer;
}

.grid.readonly .cell {
  cursor: default;
}

.cell-layer {
  position: absolute;
  inset: 0;
}

.fondo {
  z-index: 1;
}

.fondo2 {
  z-index: 2;
  background-color: #e5e5e5;
}

.punto {
  z-index: 3;
  background-color: #aaa;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.seleccion {
  z-index: 4;
  background-color: #2c2c2c;
}

.description {
  margin-top: 2rem;
  text-align: center;
  color: #6b7280;
}

.description p {
  font-size: 0.875rem;
}

.congratulations {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #22c55e;
  color: white;
  padding: 2rem;
  border-radius: 1rem;
  font-size: 1.5rem;
  font-weight: bold;
  z-index: 1000;
  display: none;
  text-align: center;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
}

.pattern-info {
  margin-top: 1rem;
  text-align: center;
  color: #6b7280;
  font-size: 0.875rem;
}

</style>
<body>
    <div class="container">
        
        <!-- Control Buttons -->
        <div class="controls">
            <button id="clearGrid" class="btn btn-default"><i class="fa-solid fa-trash"></i></button>
            <button id="toggleDots" class="btn btn-default"><i class="fa-solid fa-eye"></i></button>
            <button id="toggleSelectedBorderRadius" class="btn btn-default"><i class="fa-solid fa-square"></i></button>
            <button id="toggleNotSelectedBorderRadius" class="btn btn-default"><i class="fa-solid fa-circle"></i></button>
            <button id="submitPattern" class="btn btn-success btn-wide">Enviar Patrón</button>
        </div>

        <!-- Grids Container -->
        <div class="grids-container">
            <!-- Editable Grid -->
            <div class="grid-section">
                <h2 class="grid-title">Tu Dibujo</h2>
                <div class="grid-wrapper">
                    <div id="editableGrid" class="grid"></div>
                </div>
                <div class="pattern-info">
                    <p>Mantén presionado para dibujar</p>
                </div>
            </div>

            <!-- Display Grid -->
            <div class="grid-section">
                <h2 class="grid-title">Patrón a Replicar</h2>
                <div class="grid-wrapper">
                    <div id="displayGrid" class="grid readonly"></div>
                </div>
                <div class="pattern-info">
                    <p id="patternCount">Patrones guardados: 0</p>
                </div>
            </div>
        </div>

        <!-- Congratulations Modal -->
        <div id="congratulations" class="congratulations">
            <div>¡Felicidades!</div>
            <div style="font-size: 1rem; margin-top: 0.5rem;">¡Has replicado el patrón correctamente!</div>
        </div>
    </div>

    <script>
      const GRID_SIZE = 16
const CELL_SIZE = 30

class EnhancedDotsGrid {
  constructor() {
    this.editableGrid = this.initializeGrid()
    this.displayGrid = this.initializeGrid()
    this.showDots = true
    this.enableSelectedBorderRadius = true
    this.enableNotSelectedBorderRadius = true
    this.isDrawing = false
    this.drawingMode = null // 'select' or 'deselect'
    
    // Pattern storage
    this.patterns = [
      // Some default patterns to start with
      '1111000000000000111100000000000011110000000000001111000000000000',
      '0000111100000000000011110000000000001111000000000000111100000000',
      '1010101010101010010101010101010110101010101010100101010101010101',
      '1111111111111111100000000000000110000000000000011111111111111111'
    ]
    this.currentDisplayPattern = ''

    this.init()
  }

  initializeGrid() {
    return Array(GRID_SIZE)
      .fill(null)
      .map(() =>
        Array(GRID_SIZE)
          .fill(null)
          .map(() => ({
            selected: false,
            borderRadius: {
              topLeft: false,
              topRight: false,
              bottomLeft: false,
              bottomRight: false,
            },
          })),
      )
  }

  init() {
    this.createGrids()
    this.setupEventListeners()
    this.showRandomPattern()
    this.updatePatternCount()
  }

  createGrids() {
    this.createGrid('editableGrid', this.editableGrid, true)
    this.createGrid('displayGrid', this.displayGrid, false)
  }

  createGrid(containerId, gridData, isEditable) {
    const gridElement = document.getElementById(containerId)
    gridElement.innerHTML = ""

    for (let row = 0; row < GRID_SIZE; row++) {
      for (let col = 0; col < GRID_SIZE; col++) {
        const cell = document.createElement("div")
        cell.className = "cell"
        cell.dataset.row = row
        cell.dataset.col = col

        // FONDO layer
        const fondoLayer = document.createElement("div")
        fondoLayer.className = "cell-layer fondo"

        // FONDO 2 layer
        const fondo2Layer = document.createElement("div")
        fondo2Layer.className = "cell-layer fondo2"

        // PUNTO layer
        const puntoLayer = document.createElement("div")
        puntoLayer.className = "cell-layer punto"

        // SELECCION layer
        const seleccionLayer = document.createElement("div")
        seleccionLayer.className = "cell-layer seleccion"

        cell.appendChild(fondoLayer)
        cell.appendChild(fondo2Layer)
        cell.appendChild(puntoLayer)
        cell.appendChild(seleccionLayer)

        if (isEditable) {
          // Mouse events for drag functionality
          cell.addEventListener("mousedown", (e) => this.handleMouseDown(e, row, col))
          cell.addEventListener("mouseenter", () => this.handleMouseEnter(row, col))
          cell.addEventListener("mouseup", () => this.handleMouseUp())
          
          // Prevent context menu on right click
          cell.addEventListener("contextmenu", (e) => e.preventDefault())
        }

        gridElement.appendChild(cell)
      }
    }

    // Global mouse events for drag functionality
    if (isEditable) {
      document.addEventListener("mouseup", () => this.handleMouseUp())
    }

    this.updateGridDisplay(containerId, gridData)
  }

  setupEventListeners() {
    document.getElementById("clearGrid").addEventListener("click", () => this.clearEditableGrid())
    document.getElementById("toggleDots").addEventListener("click", () => this.toggleDots())
    document
      .getElementById("toggleSelectedBorderRadius")
      .addEventListener("click", () => this.toggleSelectedBorderRadius())
    document
      .getElementById("toggleNotSelectedBorderRadius")
      .addEventListener("click", () => this.toggleNotSelectedBorderRadius())
    document.getElementById("submitPattern").addEventListener("click", () => this.submitPattern())
  }

  handleMouseDown(e, row, col) {
    e.preventDefault()
    this.isDrawing = true
    
    // Determine drawing mode based on current cell state
    this.drawingMode = this.editableGrid[row][col].selected ? 'deselect' : 'select'
    
    // Apply the action to the clicked cell
    this.editableGrid[row][col].selected = this.drawingMode === 'select'
    
    this.updateBorderRadius(this.editableGrid)
    this.updateGridDisplay('editableGrid', this.editableGrid)
    this.checkPatternMatch()
  }

  handleMouseEnter(row, col) {
    if (!this.isDrawing) return
    
    // Apply the drawing mode to the entered cell
    this.editableGrid[row][col].selected = this.drawingMode === 'select'
    
    this.updateBorderRadius(this.editableGrid)
    this.updateGridDisplay('editableGrid', this.editableGrid)
    this.checkPatternMatch()
  }

  handleMouseUp() {
    this.isDrawing = false
    this.drawingMode = null
  }

  updateBorderRadius(gridData) {
    for (let row = 0; row < GRID_SIZE; row++) {
      for (let col = 0; col < GRID_SIZE; col++) {
        const cell = gridData[row][col]
        const isSelected = cell.selected

        // Reset border radius
        cell.borderRadius = {
          topLeft: false,
          topRight: false,
          bottomLeft: false,
          bottomRight: false,
        }

        const shouldApplyBorderRadius =
          (isSelected && this.enableSelectedBorderRadius) || (!isSelected && this.enableNotSelectedBorderRadius)

        if (shouldApplyBorderRadius) {
          // Get neighbors (treating out-of-bounds as opposite state)
          const topNeighbor = row > 0 ? gridData[row - 1][col].selected : !isSelected
          const bottomNeighbor = row < GRID_SIZE - 1 ? gridData[row + 1][col].selected : !isSelected
          const leftNeighbor = col > 0 ? gridData[row][col - 1].selected : !isSelected
          const rightNeighbor = col < GRID_SIZE - 1 ? gridData[row][col + 1].selected : !isSelected

          // Get diagonal neighbors
          const topLeftDiagonal = row > 0 && col > 0 ? gridData[row - 1][col - 1].selected : !isSelected
          const topRightDiagonal = row > 0 && col < GRID_SIZE - 1 ? gridData[row - 1][col + 1].selected : !isSelected
          const bottomLeftDiagonal = row < GRID_SIZE - 1 && col > 0 ? gridData[row + 1][col - 1].selected : !isSelected
          const bottomRightDiagonal =
            row < GRID_SIZE - 1 && col < GRID_SIZE - 1 ? gridData[row + 1][col + 1].selected : !isSelected

          if (isSelected) {
            // Para casillas SELECCIONADAS: border radius cuando una esquina está en contacto con 3 casillas NO seleccionadas
            if (topNeighbor !== isSelected && leftNeighbor !== isSelected && topLeftDiagonal !== isSelected) {
              cell.borderRadius.topLeft = true
            }
            if (topNeighbor !== isSelected && rightNeighbor !== isSelected && topRightDiagonal !== isSelected) {
              cell.borderRadius.topRight = true
            }
            if (bottomNeighbor !== isSelected && leftNeighbor !== isSelected && bottomLeftDiagonal !== isSelected) {
              cell.borderRadius.bottomLeft = true
            }
            if (bottomNeighbor !== isSelected && rightNeighbor !== isSelected && bottomRightDiagonal !== isSelected) {
              cell.borderRadius.bottomRight = true
            }
          } else {
            // Para casillas NO SELECCIONADAS: border radius cuando una esquina está en contacto con 2 casillas SELECCIONADAS contiguas
            if (topNeighbor !== isSelected && leftNeighbor !== isSelected) {
              cell.borderRadius.topLeft = true
            }
            if (topNeighbor !== isSelected && rightNeighbor !== isSelected) {
              cell.borderRadius.topRight = true
            }
            if (bottomNeighbor !== isSelected && leftNeighbor !== isSelected) {
              cell.borderRadius.bottomLeft = true
            }
            if (bottomNeighbor !== isSelected && rightNeighbor !== isSelected) {
              cell.borderRadius.bottomRight = true
            }
          }
        }
      }
    }
  }

  getBorderRadiusStyle(borderRadius) {
    return {
      borderTopLeftRadius: borderRadius.topLeft ? "8px" : "0px",
      borderTopRightRadius: borderRadius.topRight ? "8px" : "0px",
      borderBottomLeftRadius: borderRadius.bottomLeft ? "8px" : "0px",
      borderBottomRightRadius: borderRadius.bottomRight ? "8px" : "0px",
    }
  }

  updateGridDisplay(containerId, gridData) {
    const gridElement = document.getElementById(containerId)
    const cells = gridElement.querySelectorAll(".cell")

    cells.forEach((cellElement, index) => {
      const row = Math.floor(index / GRID_SIZE)
      const col = index % GRID_SIZE
      const cellData = gridData[row][col]

      const fondoLayer = cellElement.querySelector(".fondo")
      const fondo2Layer = cellElement.querySelector(".fondo2")
      const puntoLayer = cellElement.querySelector(".punto")
      const seleccionLayer = cellElement.querySelector(".seleccion")

      // Update FONDO layer
      fondoLayer.style.backgroundColor = cellData.selected ? "#e5e5e5" : "#2c2c2c"

      // Update FONDO 2 layer
      if (!cellData.selected) {
        fondo2Layer.style.display = "block"
        const borderStyle = this.getBorderRadiusStyle(cellData.borderRadius)
        Object.assign(fondo2Layer.style, borderStyle)
      } else {
        fondo2Layer.style.display = "none"
      }

      // Update PUNTO layer
      if (!cellData.selected && this.showDots) {
        puntoLayer.style.display = "block"
      } else {
        puntoLayer.style.display = "none"
      }

      // Update SELECCION layer
      if (cellData.selected) {
        seleccionLayer.style.display = "block"
        const borderStyle = this.getBorderRadiusStyle(cellData.borderRadius)
        Object.assign(seleccionLayer.style, borderStyle)
      } else {
        seleccionLayer.style.display = "none"
      }
    })
  }

  clearEditableGrid() {
    this.editableGrid = this.initializeGrid()
    this.updateGridDisplay('editableGrid', this.editableGrid)
  }

  toggleDots() {
    this.showDots = !this.showDots
    const button = document.getElementById("toggleDots")
    button.innerHTML = this.showDots ? '<i class="fa-solid fa-eye"></i>' : '<i class="fa-solid fa-eye-slash"></i>'
    button.className = this.showDots ? "btn btn-default" : "btn btn-secondary"
    this.updateGridDisplay('editableGrid', this.editableGrid)
    this.updateGridDisplay('displayGrid', this.displayGrid)
  }

  toggleSelectedBorderRadius() {
    this.enableSelectedBorderRadius = !this.enableSelectedBorderRadius
    const button = document.getElementById("toggleSelectedBorderRadius")
    button.innerHTML = this.enableSelectedBorderRadius
      ? '<i class="fa-solid fa-square"></i>'
      : '<i class="fa-regular fa-square"></i>'
    button.className = this.enableSelectedBorderRadius ? "btn btn-default" : "btn btn-secondary"
    this.updateBorderRadius(this.editableGrid)
    this.updateBorderRadius(this.displayGrid)
    this.updateGridDisplay('editableGrid', this.editableGrid)
    this.updateGridDisplay('displayGrid', this.displayGrid)
  }

  toggleNotSelectedBorderRadius() {
    this.enableNotSelectedBorderRadius = !this.enableNotSelectedBorderRadius
    const button = document.getElementById("toggleNotSelectedBorderRadius")
    button.innerHTML = this.enableNotSelectedBorderRadius
      ? '<i class="fa-solid fa-circle"></i>'
      : '<i class="fa-regular fa-circle"></i>'
    button.className = this.enableNotSelectedBorderRadius ? "btn btn-default" : "btn btn-secondary"
    this.updateBorderRadius(this.editableGrid)
    this.updateBorderRadius(this.displayGrid)
    this.updateGridDisplay('editableGrid', this.editableGrid)
    this.updateGridDisplay('displayGrid', this.displayGrid)
  }

  // Convert grid to binary string
  gridToBinaryString(gridData) {
    let binaryString = ''
    for (let row = 0; row < GRID_SIZE; row++) {
      for (let col = 0; col < GRID_SIZE; col++) {
        binaryString += gridData[row][col].selected ? '1' : '0'
      }
    }
    return binaryString
  }

  // Convert binary string to grid
  binaryStringToGrid(binaryString) {
    const gridData = this.initializeGrid()
    for (let i = 0; i < binaryString.length && i < GRID_SIZE * GRID_SIZE; i++) {
      const row = Math.floor(i / GRID_SIZE)
      const col = i % GRID_SIZE
      gridData[row][col].selected = binaryString[i] === '1'
    }
    return gridData
  }

  // Submit current pattern
  submitPattern() {
    const binaryString = this.gridToBinaryString(this.editableGrid)
    
    // Don't add empty patterns or duplicates
    if (binaryString.includes('1') && !this.patterns.includes(binaryString)) {
      this.patterns.push(binaryString)
      this.updatePatternCount()
      
      // Show success feedback
      const button = document.getElementById("submitPattern")
      const originalText = button.innerHTML
      button.innerHTML = '¡Guardado!'
      button.className = 'btn btn-success btn-wide'
      
      setTimeout(() => {
        button.innerHTML = originalText
      }, 1500)
    }
  }

  // Show random pattern from the list
  showRandomPattern() {
    if (this.patterns.length === 0) return
    
    let randomPattern
    do {
      randomPattern = this.patterns[Math.floor(Math.random() * this.patterns.length)]
    } while (randomPattern === this.currentDisplayPattern && this.patterns.length > 1)
    
    this.currentDisplayPattern = randomPattern
    this.displayGrid = this.binaryStringToGrid(randomPattern)
    this.updateBorderRadius(this.displayGrid)
    this.updateGridDisplay('displayGrid', this.displayGrid)
  }

  // Check if editable grid matches display grid
  checkPatternMatch() {
    const editableBinary = this.gridToBinaryString(this.editableGrid)
    const displayBinary = this.gridToBinaryString(this.displayGrid)
    
    if (editableBinary === displayBinary && editableBinary.includes('1')) {
      this.showCongratulations()
      // Show new pattern after a delay
      setTimeout(() => {
        this.showRandomPattern()
      }, 2000)
    }
  }

  // Show congratulations message
  showCongratulations() {
    const congratsElement = document.getElementById("congratulations")
    congratsElement.style.display = "block"
    
    setTimeout(() => {
      congratsElement.style.display = "none"
    }, 3000)
  }

  // Update pattern count display
  updatePatternCount() {
    document.getElementById("patternCount").textContent = `Patrones guardados: ${this.patterns.length}`
  }
}

// Initialize the enhanced grid when the page loads
document.addEventListener("DOMContentLoaded", () => {
  new EnhancedDotsGrid()
})

    </script>
</body>
</html>
